<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Closing Coalition — Exam</title>
  <style>
    :root{
      --bg1:#071423;
      --bg2:#0b1220;
      --card: rgba(255,255,255,.06);
      --card2: rgba(255,255,255,.08);
      --line: rgba(255,255,255,.10);
      --text:#eaf2ff;
      --muted: rgba(234,242,255,.72);
      --muted2: rgba(234,242,255,.52);
      --accent:#2dd4bf;
      --danger:#ff5a7a;
      --ok:#22c55e;
      --shadow: 0 18px 60px rgba(0,0,0,.55);
      --r:18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% 20%, rgba(45,212,191,.18), transparent 55%),
        radial-gradient(900px 600px at 75% 80%, rgba(99,102,241,.14), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      padding:20px;
    }
    .wrap{width:min(1100px, 100%); margin:0 auto; display:grid; gap:14px;}
    .card{
      background: linear-gradient(180deg, var(--card2), var(--card));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .head{
      padding:16px 18px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid var(--line);
    }
    .brand{display:flex; gap:12px; align-items:center;}
    .dot{
      width:40px; height:40px;
      border-radius:12px;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.35), rgba(255,255,255,.06) 42%, rgba(45,212,191,.22) 100%),
                  linear-gradient(180deg, rgba(45,212,191,.55), rgba(45,212,191,.12));
      border:1px solid rgba(255,255,255,.14);
    }
    .title{font-weight:900; letter-spacing:.2px; line-height:1.05}
    .sub{font-size:12px; color:var(--muted2); margin-top:2px}
    .right{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
    .badge{
      font-size:12px;
      font-weight:900;
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--muted);
      max-width: 320px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .badge.ok{border-color: rgba(34,197,94,.35); color: rgba(220,255,233,.92)}
    .badge.err{border-color: rgba(255,90,122,.35); color: rgba(255,220,228,.92)}
    .btn{
      border:none;
      cursor:pointer;
      padding:10px 12px;
      border-radius: 14px;
      font-weight:900;
      color: var(--text);
      background: linear-gradient(180deg, rgba(45,212,191,.35), rgba(0,0,0,.18));
      border:1px solid rgba(45,212,191,.28);
      transition: transform .05s ease, filter .15s ease;
    }
    .btn.secondary{
      background: rgba(0,0,0,.18);
      border:1px solid var(--line);
      color: var(--muted);
    }
    .btn:active{transform: translateY(1px)}
    .btn:disabled{opacity:.55; cursor:not-allowed}

    .body{padding:16px 18px 18px}
    .grid{display:grid; grid-template-columns: 1fr; gap:12px;}
    .row2{display:grid; grid-template-columns: 1fr; gap:12px;}
    @media (min-width: 820px){ .row2{grid-template-columns: 1fr 1fr;} }

    label{display:block; font-size:12px; color:var(--muted2); margin:0 0 6px}
    select,input{
      width:100%;
      padding:12px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--text);
      outline:none;
      font-size:14px;
      font-family: var(--mono);
    }
    select:focus,input:focus{border-color: rgba(45,212,191,.45); box-shadow:0 0 0 4px rgba(45,212,191,.10)}
    .pill{
      font-family: var(--mono);
      font-size: 12px;
      padding: 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(0,0,0,.12);
      color: var(--text);
      overflow:hidden;
      white-space:nowrap;
      text-overflow:ellipsis;
    }
    .actions{display:flex; gap:10px; flex-wrap:wrap}
    .muted{color:var(--muted); font-size:13px; line-height:1.5}
    .hr{height:1px; background:var(--line); margin:14px 0}

    /* Exam UI */
    .qCard{
      padding:16px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
    }
    .qTop{display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap}
    .qTitle{font-weight:900; letter-spacing:.2px}
    .qMeta{color:var(--muted2); font-size:12px; font-family:var(--mono)}
    .question{margin:12px 0 10px; font-size:18px; font-weight:900; line-height:1.25}
    .choices{display:grid; gap:10px; margin-top:10px}
    .choice{
      padding:12px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.14);
      cursor:pointer;
      user-select:none;
      font-weight:800;
      line-height:1.25;
    }
    .choice:hover{filter:brightness(1.08)}
    .choice.locked{cursor:default; opacity:.95}
    .choice.correct{
      border-color: rgba(34,197,94,.55);
      box-shadow: 0 0 0 4px rgba(34,197,94,.10);
      background: rgba(34,197,94,.14);
      color: rgba(220,255,233,.96);
    }
    .choice.wrong{
      border-color: rgba(255,90,122,.55);
      box-shadow: 0 0 0 4px rgba(255,90,122,.10);
      background: rgba(255,90,122,.12);
      color: rgba(255,220,228,.96);
    }
    .exp{
      margin-top:12px;
      padding:12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
      color: var(--muted);
      display:none;
    }
    .exp.show{display:block}
    .exp b{color:var(--text)}
    .footerRow{display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top:12px}
    .kpiRow{display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:10px; margin-top:10px}
    @media (max-width: 700px){ .kpiRow{grid-template-columns:1fr} }
    .kpi{
      padding:12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
    }
    .kpi .h{font-size:11px; color:var(--muted2)}
    .kpi .v{font-family:var(--mono); font-weight:900; font-size:16px; margin-top:4px}

    /* Dictionary Integration */
    .dict-term{
      text-decoration: underline dotted rgba(45,212,191,.55);
      text-underline-offset: 3px;
      cursor: help;
      position: relative;
    }
    .dict-term:hover{
      color: var(--accent);
    }
    .dict-tooltip{
      position: absolute;
      bottom: calc(100% + 8px);
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(180deg, rgba(15,23,42,.98), rgba(7,20,35,.98));
      border: 1px solid rgba(45,212,191,.4);
      border-radius: 12px;
      padding: 8px 12px;
      white-space: nowrap;
      z-index: 1000;
      box-shadow: 0 12px 32px rgba(0,0,0,.7);
      pointer-events: none;
      opacity: 0;
      transition: opacity .15s ease;
    }
    .dict-term:hover .dict-tooltip{
      opacity: 1;
      pointer-events: auto;
    }
    .dict-tooltip-btn{
      background: linear-gradient(180deg, rgba(45,212,191,.35), rgba(0,0,0,.18));
      border: 1px solid rgba(45,212,191,.45);
      border-radius: 8px;
      padding: 6px 12px;
      color: var(--text);
      font-size: 12px;
      font-weight: 800;
      cursor: pointer;
      transition: filter .15s ease;
    }
    .dict-tooltip-btn:hover{
      filter: brightness(1.15);
    }
    .dict-modal{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.85);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 2000;
      padding: 20px;
    }
    .dict-modal.show{
      display: flex;
    }
    .dict-modal-content{
      background: linear-gradient(180deg, var(--card2), var(--card));
      border: 1px solid rgba(45,212,191,.35);
      border-radius: var(--r);
      box-shadow: 0 24px 60px rgba(0,0,0,.8);
      max-width: 600px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      animation: slideIn .2s ease;
    }
    @keyframes slideIn{
      from{transform: translateY(-20px); opacity:0}
      to{transform: translateY(0); opacity:1}
    }
    .dict-modal-header{
      padding: 16px 18px;
      border-bottom: 1px solid var(--line);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    .dict-modal-title{
      font-weight: 900;
      font-size: 18px;
      color: var(--accent);
    }
    .dict-modal-close{
      background: rgba(0,0,0,.18);
      border: 1px solid var(--line);
      border-radius: 8px;
      padding: 6px 12px;
      color: var(--muted);
      font-weight: 800;
      font-size: 12px;
      cursor: pointer;
    }
    .dict-modal-close:hover{
      filter: brightness(1.1);
    }
    .dict-modal-body{
      padding: 18px;
    }
    .dict-category{
      font-size: 11px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-bottom: 8px;
    }
    .dict-definition{
      font-size: 14px;
      color: var(--muted);
      line-height: 1.6;
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="card">
      <div class="head">
        <div class="brand">
          <div class="dot"></div>
          <div>
            <div class="title"> Coalition — Exam</div>
            <div class="sub">Select exam • select question count • click answers • instant explanation • uploads best result</div>
          </div>
        </div>

        <div class="right">
          <span id="userBadge" class="badge">Checking login…</span>
          <button id="logoutBtn" class="btn secondary" style="display:none">Logout</button>
        </div>
      </div>

      <div class="body">
        <div class="grid">

          <div class="row2">
            <div>
              <label for="examSelect">Select Exam</label>
              <select id="examSelect">
                <option value="MI" selected>MI</option>
                <option value="TN">TN</option>
              </select>
              <div class="muted" style="margin-top:8px">
                Files expected: <span style="font-family:var(--mono)">/exams/MIexam.js</span> and <span style="font-family:var(--mono)">/exams/TNexam.js</span>
              </div>
            </div>

            <div>
              <label for="qCount">Select questions (type a number)</label>
              <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap">
                <input id="qCount" type="number" min="1" value="25" style="flex:1; min-width:180px" />
                <div id="loadedPill" class="pill" style="min-width:240px">Loaded: —</div>
              </div>
              <div class="muted" style="margin-top:8px">
                Max will match the loaded exam bank.
              </div>
            </div>
          </div>

          <div class="actions">
            <button id="loadBtn" class="btn secondary">Load Exam Bank</button>
            <button id="startBtn" class="btn" disabled>Start Exam</button>
            <button id="retakeMissedBtn" class="btn secondary" disabled>Retake Missed (0)</button>
            <button id="finishBtn" class="btn secondary" disabled>Finish</button>
          </div>

          <div class="hr"></div>

          <div class="kpiRow">
            <div class="kpi"><div class="h">Timer</div><div class="v" id="timer">0:00</div></div>
            <div class="kpi"><div class="h">Progress</div><div class="v" id="progress">—</div></div>
            <div class="kpi"><div class="h">Score</div><div class="v" id="score">—</div></div>
            <div class="kpi"><div class="h">Missed Queue</div><div class="v" id="missedCount">0</div></div>
          </div>

          <div id="examArea" class="qCard" style="display:none">
            <div class="qTop">
              <div class="qTitle" id="qTitle">Question</div>
              <div class="qMeta" id="qMeta">—</div>
            </div>

            <div class="question" id="qText">—</div>
            <div class="choices" id="choices"></div>
            <div style="margin-top:14px">
              <button id="nextBtn" class="btn secondary" disabled style="width:100%">
                Next
              </button>
            </div>
            <div class="exp" id="explainBox">
              <b>Explanation:</b>
              <div id="explainText" style="margin-top:6px"></div>
            </div>

            <div class="footerRow">
              <span id="statusPill" class="badge">Pick an answer</span>
              <span id="uploadPill" class="badge" style="display:none"></span>
            </div>
          </div>

          <div id="doneArea" class="qCard" style="display:none">
            <div class="qTitle">Completed</div>
            <div class="muted" id="doneText" style="margin-top:10px"></div>
            <div id="retakeMissedArea" style="margin-top:16px;display:none">
              <button id="takeMissedBtn" class="btn accent">Take Missed?</button>
            </div>
          </div>

        </div>
      </div>
    </div>

  </div>

  <!-- Dictionary Modal -->
  <div id="dictModal" class="dict-modal">
    <div class="dict-modal-content">
      <div class="dict-modal-header">
        <div class="dict-modal-title" id="dictModalTerm">Term</div>
        <button class="dict-modal-close" id="dictModalClose">Close</button>
      </div>
      <div class="dict-modal-body">
        <div class="dict-category" id="dictModalCategory">Category</div>
        <div class="dict-definition" id="dictModalDefinition">Definition</div>
      </div>
    </div>
  </div>

<script type="module">
/**********************
 * CONFIG (REPLACE THIS)
 **********************/
const CLOUD_FLARE_URL = "https://closing-coalition-api.thomaslancheros06.workers.dev"; // <-- replace with your Worker URL or API proxy URL
// Expected actions on backend: me, logout, saveExamResult

/**********************
 * DICTIONARY INTEGRATION
 **********************/
const TERMS = [
  { term: "Accelerated Death Benefit", category: "Benefit / Rider", definition: "Allows an insured to access part of the death benefit while still alive if diagnosed with a terminal or qualifying illness." },
  { term: "Risk", category: "Risk Concept", definition: "The possibility of financial loss. In insurance, risk refers to the uncertainty regarding whether a loss will occur and how severe it may be." },
  { term: "Pure Risk", category: "Risk Concept", definition: "A type of risk that involves only the possibility of loss, with no opportunity for financial gain. Pure risks are the only risks that are insurable." },
  { term: "Speculative Risk", category: "Risk Concept", definition: "A type of risk that involves the possibility of loss, no loss, or financial gain. Because it includes the chance of gain, speculative risks are not insurable." },
  { term: "Accidental Death Benefit (ADB)", category: "Rider", definition: "A rider that pays an additional amount if the insured's death results from an accident, as defined in the policy." },
  { term: "Actuarial", category: "Pricing / Math", definition: "Relating to the statistical and mathematical methods insurers use to calculate risk, premiums, and reserves." },
  { term: "Beneficiary", category: "Parties", definition: "The person or entity designated to receive the death benefit when the insured dies." },
  { term: "Modified Endowment Contract (MEC)", category: "Tax Classification", definition: "A life insurance policy that fails the IRS seven-pay test, causing loans and withdrawals to be taxed as income first and potentially subject to a 10% penalty if taken before age 59½. The death benefit remains income-tax free." },
  { term: "Binding Receipt", category: "Underwriting / Receipt", definition: "A receipt that provides temporary coverage immediately at application, even before underwriting is complete, subject to company rules." },
  { term: "Loss Factor", category: "Risk / Rating Concept", definition: "A numerical adjustment applied to premium calculations based on an insured's past loss experience. Higher loss history increases the loss factor and results in higher premiums." },
  { term: "Peril", category: "Risk Concept", definition: "The specific cause of a loss. In life insurance, the primary peril is death; in health insurance, it includes sickness or injury." },
  { term: "Liability", category: "Legal / Risk Concept", definition: "A legal responsibility for damages or loss caused to another person. In insurance, liability refers to the obligation to pay for harm or injury the insured legally caused." },
  { term: "Broker", category: "Producer Type", definition: "An insurance producer who legally represents the insured, not the insurer, in placing insurance." },
  { term: "Cash Value", category: "Policy Value", definition: "The savings component inside permanent life policies that grows tax-deferred and can be accessed through loans or surrender." },
  { term: "Fair Credit Reporting Act (FCRA)", category: "Federal Regulation", definition: "A federal law that regulates how insurers and other entities collect and use consumer credit and investigative reports. It requires disclosure, written authorization for investigative reports, and the right for consumers to know and correct information." },
  { term: "Cash Surrender Value", category: "Policy Value", definition: "The amount the policyowner receives if the policy is voluntarily terminated and surrendered back to the insurer." },
  { term: "Contestability Period", category: "Policy Clause", definition: "A period, usually two years, during which the insurer can rescind coverage or deny a claim due to material misrepresentation." },
  { term: "Consideration", category: "Contract Element", definition: "The value each party gives: the insured's premium and truthful application, and the insurer's promise to pay according to the policy." },
  { term: "Conditional Receipt", category: "Underwriting / Receipt", definition: "A receipt stating that coverage is effective only if the applicant is later found to meet the insurer's underwriting requirements." },
  { term: "Death Benefit", category: "Core Benefit", definition: "The amount paid to the beneficiary when the insured dies while the policy is in force." },
  { term: "Dividends", category: "Participating Policy", definition: "Refunds of excess premium on participating policies. Not guaranteed and not considered taxable income when treated as a return of premium." },
  { term: "Endowment", category: "Policy Type", definition: "A policy designed to pay the face amount either at the insured's death or at the end of a specified period or age." },
  { term: "Evidence of Insurability", category: "Underwriting", definition: "Information, such as medical history and exams, used by underwriters to assess the risk of an applicant." },
  { term: "Free-Look Period", category: "Policy Right", definition: "A required period, typically 10–30 days, during which the policyowner may cancel the policy for a full refund." },
  { term: "Fraud", category: "Legal / Misconduct", definition: "Intentional misrepresentation or concealment of a material fact. It can void a policy even after the contestability period." },
  { term: "Grace Period", category: "Policy Clause", definition: "A time period, usually 30 or 31 days, after a premium due date during which coverage continues even if the premium has not yet been paid." },
  { term: "Gross Premium", category: "Premium", definition: "The total premium charged, including the cost of mortality, expenses, and other loading factors." },
  { term: "Hazard", category: "Risk Concept", definition: "A condition that increases the likelihood or severity of a loss, such as poor health, dangerous occupation, or risky habits." },
  { term: "Insurable Interest", category: "Legal Requirement", definition: "A financial or emotional relationship where the policyowner would suffer a loss from the insured's death. Must exist at policy issue." },
  { term: "Incontestability Clause", category: "Policy Clause", definition: "A clause stating that after a set period (usually two years), the insurer cannot void the policy for misrepresentations, except in cases of fraud." },
  { term: "Illustration", category: "Policy Disclosure", definition: "A presentation or projection of how a policy may perform in the future. Contains both guaranteed and non-guaranteed elements." },
  { term: "Lapse", category: "Policy Status", definition: "Termination of coverage due to nonpayment of premium beyond the grace period." },
  { term: "Level Premium", category: "Premium Structure", definition: "A premium that remains the same throughout the premium-paying period of the policy." },
  { term: "Loan Provision", category: "Policy Feature", definition: "A provision allowing the policyowner to borrow against the policy's cash value, usually with interest." },
  { term: "Material Misrepresentation", category: "Underwriting / Legal", definition: "A false statement that would influence an insurer's decision to accept or rate a risk. May lead to rescission of the policy." },
  { term: "Nonforfeiture Options", category: "Policy Rights", definition: "Required options in permanent policies that allow the policyowner to use the cash value if premium payments stop: cash surrender, reduced paid-up, or extended term." },
  { term: "Net Premium", category: "Premium", definition: "The portion of the premium that covers the cost of mortality only, without expenses or other charges." },
  { term: "Owner (Policyowner)", category: "Parties", definition: "The person or entity with legal rights to the policy, including naming beneficiaries and accessing cash value." },
  { term: "Participating Policy", category: "Policy Type", definition: "A policy issued by a mutual insurer that may pay dividends to policyowners." },
  { term: "Policy Loan", category: "Policy Feature", definition: "A loan made by the insurer to the policyowner using the policy's cash value as collateral. Unpaid loans reduce the death benefit." },
  { term: "Premium", category: "Payment", definition: "The periodic payment required to keep an insurance policy in force." },
  { term: "Primary Beneficiary", category: "Beneficiaries", definition: "The first person or entity in line to receive the death benefit when the insured dies." },
  { term: "Reinstatement", category: "Policy Restoration", definition: "The process of restoring a lapsed policy, typically requiring back premiums, interest, and proof of insurability." },
  { term: "Replacement", category: "Regulated Practice", definition: "The act of buying new insurance that results in the existing policy being lapsed, surrendered, or reduced. Heavily regulated to protect consumers." },
  { term: "Rider", category: "Policy Add-On", definition: "An optional feature added to a policy that changes or adds coverage, often for an additional premium." },
  { term: "Settlement Options", category: "Benefit Payment", definition: "Choices for how the death benefit is paid: lump sum, interest only, fixed period, fixed amount, or life income." },
  { term: "Standard Risk", category: "Underwriting Class", definition: "An average risk category where the insured fits normal underwriting standards and receives standard rates." },
  { term: "Substandard Risk", category: "Underwriting Class", definition: "A higher-than-average risk that may be insured with higher premiums or special conditions." },
  { term: "Term Life Insurance", category: "Policy Type", definition: "Life insurance that provides pure death-benefit protection for a specified period with no cash value." },
  { term: "Twisting", category: "Illegal Practice", definition: "The unethical or illegal act of inducing a policyowner to replace a policy through misrepresentation or incomplete comparison." },
  { term: "Underwriting", category: "Process", definition: "The process by which an insurer evaluates an applicant's risk to decide whether to issue coverage and at what premium." },
  { term: "Unearned Premium", category: "Premium", definition: "The portion of the premium that has been paid but not yet used to provide coverage for a future period." },
  { term: "Variable Life Insurance", category: "Policy Type", definition: "A type of permanent life insurance with a cash value invested in separate accounts, where values can go up or down. Requires both a life and securities license." },
  { term: "Waiver of Premium", category: "Rider", definition: "A rider that waives future premiums if the insured becomes disabled as defined in the policy." },
  { term: "Whole Life Insurance", category: "Policy Type", definition: "A form of permanent life insurance with guaranteed death benefit, fixed premiums, and guaranteed cash value accumulation." },
  { term: "Yearly Renewable Term (YRT)", category: "Policy Structure", definition: "A one-year term policy that can be renewed each year, typically with premiums that increase as the insured gets older." },
  { term: "Insolvent", category: "Financial Condition", definition: "A situation where an insurer's liabilities are greater than its assets, so it cannot meet its financial obligations as they come due." },
  { term: "Level Coverage", category: "Benefit Structure", definition: "A death benefit that stays the same (level) for the entire coverage period instead of increasing or decreasing over time." },
  { term: "Distribution Period", category: "Annuity Phase", definition: "The payout or annuitization phase of an annuity when the accumulated value is paid out to the annuitant as income." },
  { term: "Refund Annuity", category: "Annuity Payout Option", definition: "A life income annuity that guarantees at least a return of the original principal; if the annuitant dies early, any remaining amount is paid to a beneficiary in a lump sum or installments." },
  { term: "McCarran-Ferguson Act", category: "Insurance Regulation", definition: "A federal law stating that insurance regulation is left to the states, and that federal law applies only when it specifically relates to insurance." },
  { term: "Adhesion", category: "Contract Law", definition: "A contract written entirely by one party (the insurer). Ambiguities are interpreted in favor of the insured." },
  { term: "Aleatory", category: "Contract Law", definition: "A contract where the exchange of value is unequal; the insurer may pay far more in claims than the insured paid in premiums." },
  { term: "Unilateral Contract", category: "Contract Law", definition: "Only one party—the insurer—makes a legally enforceable promise, which is to pay a claim in exchange for premium." },
  { term: "Utmost Good Faith", category: "Contract Principle", definition: "The legal requirement that both insurer and applicant act honestly and disclose all material facts." },
  { term: "Suitability", category: "Regulation", definition: "The requirement that a producer must ensure a product is appropriate for the client's financial situation and objectives." },
  { term: "Replacement Regulations", category: "Regulated Practice", definition: "Rules requiring specific disclosures and comparison forms when a client is replacing existing life insurance or annuities." },
  { term: "MIB (Medical Information Bureau)", category: "Underwriting", definition: "A cooperative data service used by insurers to check for inconsistencies or red flags in applicants' medical histories." },
  { term: "APS (Attending Physician Statement)", category: "Underwriting", definition: "A medical report requested from the applicant's doctor to clarify or verify health information." },
  { term: "Moral Hazard", category: "Risk Concept", definition: "A risk created by a person's habits, character, lifestyle, or dishonest tendencies." },
  { term: "Morale Hazard", category: "Risk Concept", definition: "A risk created by carelessness or irresponsibility, such as failing to maintain healthy habits." },
  { term: "Human Life Value", category: "Needs Analysis", definition: "A method of estimating insurance needs based on the economic value a person provides over their working lifetime." },
  { term: "Needs Analysis", category: "Financial Planning", definition: "A method to determine how much insurance a client requires by evaluating debts, income needs, and financial goals." },
  { term: "Collateral Assignment", category: "Policy Rights", definition: "A temporary transfer of some policy rights to a lender as security for a loan." },
  { term: "Absolute Assignment", category: "Policy Rights", definition: "A permanent transfer of all ownership rights of a life insurance policy to another person or entity." },
  { term: "STOLI (Stranger-Originated Life Insurance)", category: "Illegal Practice", definition: "An illegal arrangement where a third party with no insurable interest initiates a life insurance policy for profit." },
  { term: "Viatication", category: "Policy Transaction", definition: "Selling a life insurance policy to a third party for cash when the insured is terminally ill." },
  { term: "Interest-Only Option", category: "Settlement Option", definition: "The insurer holds the death benefit and pays the beneficiary interest earned on the fund." },
  { term: "Reduced Paid-Up Insurance", category: "Nonforfeiture Option", definition: "Uses the cash value to purchase a smaller, fully paid-up permanent policy with no future premiums." },
  { term: "Adversity", category: "General Term", definition: "A condition of hardship, difficulty, or misfortune. Not an insurance exam term but used to describe challenging circumstances affecting individuals or families." },
  { term: "Adverse Selection", category: "Underwriting Concept", definition: "The tendency of individuals with higher-than-average risk to seek insurance more often than those with lower risk, potentially leading to insurer losses. Underwriting controls adverse selection." },
  { term: "Extended Term Insurance", category: "Nonforfeiture Option", definition: "Uses the cash value to buy a term policy of the same face amount for as long as the cash value allows." },
  { term: "Fixed Annuity", category: "Annuity Type", definition: "An annuity with guaranteed interest rates and fixed payments; the insurer bears the investment risk." },
  { term: "Indexed Annuity", category: "Annuity Type", definition: "An annuity where returns are tied to a market index such as the S&P 500, offering limited upside with principal protection." },
  { term: "Exclusion Ratio", category: "Taxation", definition: "The formula used to determine how much of each annuity payment is taxable versus tax-free return of principal." },
  { term: "1035 Exchange", category: "Tax Code", definition: "A tax-free exchange of one life insurance or annuity contract for another similar contract." },
  { term: "Renewability", category: "Policy Feature", definition: "The ability to renew a term policy without proving insurability." },
  { term: "Convertibility", category: "Policy Feature", definition: "Allows a term policy to be converted into permanent insurance without proof of insurability." },
  { term: "Risk Classification", category: "Underwriting", definition: "The method insurers use to group applicants by health and lifestyle factors: preferred, standard, substandard." },
  { term: "Free Look", category: "Consumer Protection", definition: "A mandatory period, usually 10–30 days, where the client can cancel the policy for a full refund." },
  { term: "Warranty", category: "Legal", definition: "A statement guaranteed to be true; in insurance, material misstatements can void coverage." },
  { term: "Representation", category: "Legal", definition: "A statement believed to be true to the best of the applicant's knowledge; most insurance applications rely on representations." },
  { term: "Spendthrift Clause", category: "Policy Protection", definition: "A provision that protects the policy's proceeds from the beneficiary's creditors by preventing the beneficiary from assigning or pledging the death benefit before it is paid." },
  { term: "Fraternal Benefit Society", category: "Insurer Type", definition: "A membership-based organization that provides insurance benefits to its members. Fraternals operate on a nonprofit basis, are often tied to a lodge or religious/ethnic group, and issue certificates instead of traditional policies." },
  { term: "Guarantee", category: "Contract Feature", definition: "A promise written into the policy ensuring that certain values or benefits—such as premium, cash value growth, or death benefit—will not change regardless of market conditions." },
  { term: "Voidable Contract", category: "Contract Law", definition: "A valid contract that can be legally voided by one party due to reasons such as misrepresentation, concealment, or lack of capacity. If not voided, it remains enforceable." },
  { term: "Conditional Contract", category: "Contract Law", definition: "A contract where the insurer's obligation to pay a benefit is dependent on certain conditions being met, such as timely premium payment and proof of loss." },
  { term: "Ambiguity", category: "Contract Interpretation", definition: "A situation where wording in an insurance contract can be interpreted in more than one way. Under the doctrine of adhesion, any ambiguity is interpreted in favor of the insured, not the insurer." },
  { term: "Principal", category: "Agency Law", definition: "The party in an agency relationship who authorizes another (the agent) to act on their behalf. In insurance, the insurer is the principal, responsible for the actions and representations of its appointed producers." },
  { term: "Key Person Insurance", category: "Business Insurance", definition: "Life insurance purchased by a business on the life of a key employee or owner. The business is the owner, premium payer, and beneficiary, and uses the death benefit to cover financial losses caused by that person's death." },
  { term: "Investment Risk", category: "Risk Concept", definition: "The risk that investment performance will be lower than expected or result in a loss. In insurance, investment risk is assumed by the policyowner in variable products and by the insurer in fixed products." },
  { term: "Immediate Annuity", category: "Annuity Type", definition: "An annuity that begins paying income shortly after a lump-sum premium is paid, typically within one year." },
  { term: "Deferred Annuity", category: "Annuity Type", definition: "An annuity that accumulates value during an accumulation period and begins payments at a later date during the distribution period." },
  { term: "Annuity", category: "Insurance Product", definition: "A contract between an individual and an insurer designed to accumulate funds and then distribute income, often used to provide retirement income." },
  { term: "Producer", category: "Insurance Role", definition: "A licensed individual authorized to sell, solicit, or negotiate insurance on behalf of an insurer. The term includes both agents and brokers." },
  { term: "Aleatory Contract", category: "Contract Law", definition: "A contract in which the exchange of value is unequal. The insured may pay relatively small premiums while the insurer may pay out a much larger benefit, depending on uncertain events." }
];

// Build dictionary lookup map
const termMap = new Map();
TERMS.forEach(t => {
  const key = t.term.toLowerCase();
  termMap.set(key, t);
  // Also add without parenthetical parts for easier matching
  const baseKey = key.replace(/\s*\([^)]*\)/g, '').trim();
  if (baseKey !== key) {
    termMap.set(baseKey, t);
  }
});

// Highlight terms in text
function highlightTerms(text) {
  if (!text) return text;
  
  // Create array of terms sorted by length (longest first to avoid partial matches)
  const sortedTerms = Array.from(new Set(termMap.keys()))
    .sort((a, b) => b.length - a.length);
  
  let result = text;
  const matches = [];
  
  // Find all matches
  sortedTerms.forEach(term => {
    const regex = new RegExp(`\\b${term}\\b`, 'gi');
    let match;
    while ((match = regex.exec(text)) !== null) {
      matches.push({
        start: match.index,
        end: match.index + match[0].length,
        term: match[0],
        termKey: term
      });
    }
  });
  
  // Sort matches by position
  matches.sort((a, b) => a.start - b.start);
  
  // Remove overlapping matches (keep first)
  const filtered = [];
  let lastEnd = -1;
  matches.forEach(m => {
    if (m.start >= lastEnd) {
      filtered.push(m);
      lastEnd = m.end;
    }
  });
  
  // Build result with highlights (work backwards to preserve indices)
  filtered.reverse().forEach(m => {
    const termData = termMap.get(m.termKey.toLowerCase());
    if (termData) {
      const before = result.substring(0, m.start);
      const after = result.substring(m.end);
      const highlighted = `<span class="dict-term" data-term="${m.termKey.toLowerCase()}">${m.term}<span class="dict-tooltip"><button class="dict-tooltip-btn" onclick="showDefinition('${m.termKey.toLowerCase()}')">Define</button></span></span>`;
      result = before + highlighted + after;
    }
  });
  
  return result;
}

// Show definition modal
window.showDefinition = function(termKey) {
  const termData = termMap.get(termKey.toLowerCase());
  if (!termData) return;
  
  document.getElementById('dictModalTerm').textContent = termData.term;
  document.getElementById('dictModalCategory').textContent = termData.category;
  document.getElementById('dictModalDefinition').textContent = termData.definition;
  document.getElementById('dictModal').classList.add('show');
};

// Close modal
document.getElementById('dictModalClose').addEventListener('click', () => {
  document.getElementById('dictModal').classList.remove('show');
});

document.getElementById('dictModal').addEventListener('click', (e) => {
  if (e.target.id === 'dictModal') {
    document.getElementById('dictModal').classList.remove('show');
  }
});

/**********************
 * LOGIN GUARD (token)
 **********************/
const LS_TOKEN = "cc_token";
const LS_EXPIRES = "cc_expires_at";
function getToken(){ return localStorage.getItem(LS_TOKEN) || ""; }

const userBadge = document.getElementById("userBadge");
const logoutBtn = document.getElementById("logoutBtn");

function setBadge(kind, text){
  userBadge.className = "badge " + (kind === "ok" ? "ok" : kind === "err" ? "err" : "");
  userBadge.textContent = text;
}

async function api(action, payload){
  const res = await fetch(CLOUD_FLARE_URL, {
    method: "POST",
    headers: { "Content-Type":"application/json" },
    body: JSON.stringify({ action, ...payload })
  });
  const txt = await res.text();
  let data;
  try { data = JSON.parse(txt); } catch { throw new Error(txt || "Bad response"); }
  if (!data || data.ok !== true) {
    const msg = (data && (data.error || data.detail)) ? (data.error + (data.detail ? " — " + data.detail : "")) : "Request failed";
    throw new Error(msg);
  }
  return data;
}

let loginEmail = "";

async function requireLogin(){
  const token = getToken();
  if (!token){
    window.location.href = "index.html";
    return;
  }

  try {
    const me = await api("me", { token });

    loginEmail = me.loginEmail || "";
    setBadge("ok", loginEmail ? `Logged in: ${loginEmail}` : "Logged in");
  } catch (e) {
    // token invalid or expired
    localStorage.removeItem(LS_TOKEN);
    localStorage.removeItem(LS_EXPIRES);
    window.location.href = "index.html";
  }
}


/**********************
 * EXAM BANK LOADING
 **********************/
const examSelect = document.getElementById("examSelect");
const loadBtn = document.getElementById("loadBtn");
const startBtn = document.getElementById("startBtn");
const nextBtn = document.getElementById("nextBtn");
const finishBtn = document.getElementById("finishBtn");
const qCountEl = document.getElementById("qCount");
const loadedPill = document.getElementById("loadedPill");

const examArea = document.getElementById("examArea");
const doneArea = document.getElementById("doneArea");

const qTitle = document.getElementById("qTitle");
const qMeta = document.getElementById("qMeta");
const qText = document.getElementById("qText");
const choicesEl = document.getElementById("choices");

const explainBox = document.getElementById("explainBox");
const explainText = document.getElementById("explainText");

const statusPill = document.getElementById("statusPill");
const uploadPill = document.getElementById("uploadPill");

const timerEl = document.getElementById("timer");
const progressEl = document.getElementById("progress");
const scoreEl = document.getElementById("score");
const missedCountEl = document.getElementById("missedCount");
const retakeMissedBtn = document.getElementById("retakeMissedBtn");
const takeMissedBtn = document.getElementById("takeMissedBtn");
const retakeMissedArea = document.getElementById("retakeMissedArea");

let bank = [];
let deck = [];
let idx = 0;
let correct = 0;
let answered = 0;
let locked = false;

let startTs = 0;
let timerInt = null;

// Missed questions tracking
let missedThisSession = []; // questions missed in current exam
let missedFromServer = [];  // loaded from server for retake
let isRetakeMode = false;
let missedForRetake = [];   // stored for "Take Missed?" immediate retake

function fmtTime(sec){
  sec = Math.max(0, Math.floor(sec));
  const m = Math.floor(sec/60);
  const s = sec % 60;
  return m + ":" + (s < 10 ? "0" : "") + s;
}

function shuffle(arr){
  return arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(x=>x[1]);
}

function clearGlobals(){
  // remove common exports so we don't accidentally reuse stale values
  try { delete window.EXAM_QUESTIONS; } catch {}
  try { delete window.MI_EXAM_QUESTIONS; } catch {}
  try { delete window.TN_EXAM_QUESTIONS; } catch {}
  try { delete window.MIEXAM; } catch {}
  try { delete window.TNEXAM; } catch {}
}

function pickQuestionsFromWindow(){
  // priority list
  const candidates = [
    window.EXAM_QUESTIONS,
    window.MI_EXAM_QUESTIONS,
    window.TN_EXAM_QUESTIONS,
    window.MIEXAM,
    window.TNEXAM
  ].filter(Array.isArray);

  if (candidates.length) return candidates[0];

  // last resort: scan window for an array of objects that look like questions
  for (const k of Object.keys(window)){
    const v = window[k];
    if (Array.isArray(v) && v.length && v[0] && typeof v[0] === "object" && ("question" in v[0]) && ("correct" in v[0]) && ("wrongs" in v[0])){
      return v;
    }
  }
  return [];
}

function loadScript(src){
  return new Promise((resolve, reject) => {
    // Remove any existing script with the same source pattern
    const existing = document.querySelector(`script[src^="${src.split('?')[0]}"]`);
    if (existing) {
      existing.remove();
    }
    
    const s = document.createElement("script");
    s.src = src + "?v=" + Date.now(); // cache-bust for updates
    s.onload = () => {
      console.log("Script loaded successfully:", src);
      resolve();
    };
    s.onerror = (e) => {
      console.error("Script failed to load:", src, e);
      reject(new Error("Failed to load " + src));
    };
    document.head.appendChild(s);
  });
}

async function loadExamBank(){
  const code = examSelect.value; // "MI" or "TN"
  const src = "./exams/" + code + "exam.js"; // MIexam.js / TNexam.js
  // NOTE: your file names are MIexam.js and TNexam.js. This matches.
  
  console.log("Loading exam bank from:", src);

  startBtn.disabled = true;
  loadedPill.textContent = "Loaded: …";
  bank = [];
  deck = [];
  idx = 0;

  clearGlobals();

  try {
    await loadScript(src);
  } catch(e) {
    console.error("Failed to load script:", e);
    throw e;
  }

  bank = pickQuestionsFromWindow();

  const total = bank.length;
  loadedPill.textContent = "Loaded: " + total;

  // enforce max
  qCountEl.max = String(total || 1);
  if (Number(qCountEl.value) > total) qCountEl.value = String(total || 1);

  if (!total){
    startBtn.disabled = true;
    statusPill.textContent = "No questions loaded";
    return;
  }

  statusPill.textContent = "Ready";
  startBtn.disabled = false;
}

loadBtn.addEventListener("click", async () => {
  statusPill.textContent = "Loading exam bank…";
  try{
    await loadExamBank();
  } catch(e){
    loadedPill.textContent = "Loaded: 0";
    startBtn.disabled = true;
    statusPill.textContent = "Load failed: " + e.message;
    console.error("Load error:", e);
    alert("Failed to load exam: " + e.message + "\n\nMake sure the file exists at: ./exams/" + examSelect.value + "exam.js");
  }
});

/**********************
 * EXAM RUN
 **********************/
function resetExamState(){
  deck = [];
  idx = 0;
  correct = 0;
  answered = 0;
  locked = false;
  explainBox.classList.remove("show");
  explainText.textContent = "";
  uploadPill.style.display = "none";
  uploadPill.textContent = "";
  uploadPill.className = "badge";
  doneArea.style.display = "none";
  examArea.style.display = "none";
  retakeMissedArea.style.display = "none";
  nextBtn.disabled = true;
  finishBtn.disabled = true;
  progressEl.textContent = "—";
  scoreEl.textContent = "—";
  timerEl.textContent = "0:00";
  if (timerInt) clearInterval(timerInt);
  timerInt = null;
}

function startTimer(){
  startTs = Date.now();
  timerEl.textContent = "0:00";
  if (timerInt) clearInterval(timerInt);
  timerInt = setInterval(() => {
    const sec = (Date.now() - startTs) / 1000;
    timerEl.textContent = fmtTime(sec);
  }, 250);
}

function stopTimer(){
  if (timerInt) clearInterval(timerInt);
  timerInt = null;
  const sec = Math.floor((Date.now() - startTs) / 1000);
  return Math.max(0, sec);
}

function render(){
  const q = deck[idx];
  if (!q){
    finishExam();
    return;
  }

  locked = false;
  nextBtn.disabled = true;
  finishBtn.disabled = false;

  examArea.style.display = "";
  doneArea.style.display = "none";

  explainBox.classList.remove("show");
  explainText.textContent = "";

  qTitle.textContent = "Question";
  qMeta.textContent = `#${idx + 1} / ${deck.length}`;

  qText.innerHTML = highlightTerms(q.question || "—");
  choicesEl.innerHTML = "";

  const choices = shuffle([q.correct, ...(q.wrongs || [])]).filter(Boolean);

  if (!choices.length){
    const d = document.createElement("div");
    d.className = "muted";
    d.textContent = "No choices found for this question.";
    choicesEl.appendChild(d);
    return;
  }

  progressEl.textContent = `${idx + 1}/${deck.length}`;
  scoreEl.textContent = `${correct}/${answered}`;

  statusPill.textContent = "Pick an answer";
  statusPill.className = "badge";

  for (const opt of choices){
    const c = document.createElement("div");
    c.className = "choice";
    c.innerHTML = highlightTerms(opt);

    c.addEventListener("click", () => {
      if (locked) return;
      locked = true;

      // lock all
      const kids = Array.from(choicesEl.children);
      kids.forEach(k => k.classList.add("locked"));

      const isRight = opt === q.correct;

      // paint
      kids.forEach(k => {
        if (k.textContent === q.correct) k.classList.add("correct");
      });
      if (!isRight){
        c.classList.add("wrong");
        
        // Track this missed question
        missedThisSession.push({
          question_text: q.question,
          correct_answer: q.correct,
          user_answer: opt,
          explanation: q.explanation || "",
          difficulty: q.difficulty || "",
          wrongs: q.wrongs || []
        });
      }

      answered++;
      if (isRight) correct++;

      scoreEl.textContent = `${correct}/${answered}`;

      // show explanation
      const exp = (q.explanation || "").trim();
      explainText.innerHTML = highlightTerms(exp || "No explanation provided.");
      explainBox.classList.add("show");

      statusPill.textContent = isRight ? "Correct" : "Wrong";
      statusPill.className = "badge " + (isRight ? "ok" : "err");

      // enable next
      nextBtn.disabled = false;
    });

    choicesEl.appendChild(c);
  }
}

startBtn.addEventListener("click", () => {
  if (!bank.length){
    alert("Load an exam bank first.");
    return;
  }

  const n = Math.floor(Number(qCountEl.value || 0));
  if (!n || n < 1){
    alert("Enter a valid number of questions.");
    return;
  }
  if (n > bank.length){
    alert(`You asked for ${n}, but only ${bank.length} questions are loaded.`);
    return;
  }

  resetExamState();
  missedThisSession = []; // Clear missed questions for new exam
  isRetakeMode = false;

  deck = shuffle(bank).slice(0, n);
  idx = 0;
  correct = 0;
  answered = 0;

  startTimer();
  render();

  startBtn.disabled = true;
  loadBtn.disabled = true;
  examSelect.disabled = true;
  qCountEl.disabled = true;
  retakeMissedBtn.disabled = true;
});

nextBtn.addEventListener("click", () => {
  if (idx < deck.length - 1){
    idx++;
    render();
  } else {
    finishExam();
  }
});

finishBtn.addEventListener("click", () => finishExam());

// "Take Missed?" button - retake only missed questions
takeMissedBtn.addEventListener("click", () => {
  if (!missedForRetake.length) {
    alert("No missed questions to retake!");
    return;
  }

  // Reset exam state but keep the missed questions
  resetExamState();
  missedThisSession = [];
  isRetakeMode = true;

  // Set deck to the missed questions (shuffled)
  deck = shuffle([...missedForRetake]);
  idx = 0;
  correct = 0;
  answered = 0;

  // Update question count display
  qCountEl.value = String(deck.length);

  // Start the exam
  startTimer();
  render();

  // Disable setup UI during exam
  startBtn.disabled = true;
  loadBtn.disabled = true;
  examSelect.disabled = true;
  qCountEl.disabled = true;

  // Hide the retake area
  retakeMissedArea.style.display = "none";
});

async function finishExam(){
  const time_sec = stopTimer();
  const total = deck.length || 0;

  const score_pct = total ? Math.round((correct / total) * 100) : 0;
  const pct = total ? Math.round((correct / total) * 1000) / 10 : 0;
  examArea.style.display = "none";
  doneArea.style.display = "";

  const missedCount = missedThisSession.length;
  
  // Store missed questions for immediate retake
  missedForRetake = missedThisSession.map(q => ({
    question: q.question_text,
    correct: q.correct_answer,
    explanation: q.explanation || "",
    difficulty: q.difficulty || "",
    wrongs: q.wrongs || []
  }));
  
  document.getElementById("doneText").innerHTML = `
    <div style="font-weight:900;font-size:18px">Score: ${correct}/${total} (${pct}%)</div>
    <div style="margin-top:6px">Time: ${fmtTime(time_sec)} (${time_sec}s)</div>
    ${missedCount > 0 ? `<div style="margin-top:6px;color:var(--danger)">${missedCount} question${missedCount > 1 ? 's' : ''} missed</div>` : `<div style="margin-top:6px;color:var(--ok)">Perfect! No missed questions!</div>`}
    <div style="margin-top:10px;color:rgb(234,242,255,.72)">
      Uploading result…
    </div>
    `;

  // Show/hide "Take Missed?" button
  if (missedCount > 0) {
    retakeMissedArea.style.display = "";
    takeMissedBtn.textContent = `Take Missed? (${missedCount})`;
  } else {
    retakeMissedArea.style.display = "none";
  }

  // re-enable setup UI
  startBtn.disabled = false;
  loadBtn.disabled = false;
  examSelect.disabled = false;
  qCountEl.disabled = false;
  nextBtn.disabled = true;
  finishBtn.disabled = true;

  // Upload score
  uploadPill.style.display = "";
  uploadPill.textContent = "Uploading…";
  uploadPill.className = "badge";

  try{
    await api("saveBestExam", {
      token: getToken(),
      exam: examSelect.value,
      score_pct,
      time_sec
    });
    uploadPill.textContent = "Score saved";
    uploadPill.className = "badge ok";
  } catch(e){
    uploadPill.textContent = "Score upload failed";
    uploadPill.className = "badge err";
  }

  // Log missed questions to spreadsheet (appends forever for review)
  if (missedThisSession.length > 0) {
    try {
      await api("logMissedQuestions", {
        token: getToken(),
        exam: examSelect.value,
        missed: missedThisSession.map(q => ({
          question: q.question_text,
          answer: q.correct_answer
        }))
      });
      console.log("Missed questions logged to sheet:", missedThisSession.length);
    } catch(e) {
      console.error("Failed to log missed questions:", e);
    }
  }

  // If in retake mode and got all correct, clear those questions
  if (isRetakeMode && missedThisSession.length === 0 && deck.length > 0) {
    try {
      const questionTexts = deck.map(q => q.question);
      await api("clearMissedQuestions", {
        token: getToken(),
        exam: examSelect.value,
        questionTexts: questionTexts
      });
      console.log("Cleared mastered questions from review queue");
    } catch(e) {
      console.error("Failed to clear questions:", e);
    }
  }

  // Refresh missed questions count
  await loadMissedQuestions();
  isRetakeMode = false;
}

/**********************
 * MISSED QUESTIONS
 **********************/
async function loadMissedQuestions() {
  try {
    const exam = examSelect.value;
    const result = await api("getMissedQuestions", {
      token: getToken(),
      exam: exam
    });
    
    if (result.ok) {
      missedFromServer = result.questions || [];
      const count = missedFromServer.length;
      missedCountEl.textContent = String(count);
      retakeMissedBtn.textContent = `Retake Missed (${count})`;
      retakeMissedBtn.disabled = count === 0;
    }
  } catch(e) {
    console.error("Failed to load missed questions:", e);
    missedFromServer = [];
    missedCountEl.textContent = "?";
    retakeMissedBtn.disabled = true;
  }
}

retakeMissedBtn.addEventListener("click", async () => {
  if (!missedFromServer.length) {
    alert("No missed questions to review!");
    return;
  }

  resetExamState();
  missedThisSession = [];
  isRetakeMode = true;

  // Convert missed questions to exam format
  deck = missedFromServer.map(q => ({
    question: q.question_text,
    correct: q.correct_answer,
    explanation: q.explanation || "",
    difficulty: q.difficulty || "",
    wrongs: q.wrongs || []
  }));

  // Shuffle the deck
  deck = shuffle(deck);
  idx = 0;
  correct = 0;
  answered = 0;

  qTitle.textContent = "Review Mode";
  startTimer();
  render();

  startBtn.disabled = true;
  loadBtn.disabled = true;
  examSelect.disabled = true;
  qCountEl.disabled = true;
  retakeMissedBtn.disabled = true;
});

// Reload missed count when exam changes
examSelect.addEventListener("change", async () => {
  statusPill.textContent = "Switching exam…";
  try{
    await loadExamBank();
    await loadMissedQuestions();
  } catch(e){
    loadedPill.textContent = "Loaded: 0";
    startBtn.disabled = true;
    statusPill.textContent = "Load failed";
  }
});

/**********************
 * BOOT
 **********************/
async function boot() {
  try {
    await requireLogin();         // blocks if not logged in
    // auto-load initial exam bank
    await loadExamBank();
    // load missed questions count
    await loadMissedQuestions();
  } catch(e) {
    console.error("Auto-load failed:", e);
    statusPill.textContent = "Click 'Load Exam Bank' to start";
    statusPill.className = "badge err";
  }
}

boot();
</script>
</body>
</html>
